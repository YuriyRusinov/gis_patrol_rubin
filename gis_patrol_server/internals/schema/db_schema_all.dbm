<?xml version="1.0" encoding="UTF-8"?>
<!--
CAUTION: Do not modify this file unless you know what you are doing.
         Unexpected results may occur if the code is changed deliberately.
-->
<dbmodel pgmodeler-ver="0.9.3-alpha1" last-position="0,0" last-zoom="1" max-obj-count="123"
	 default-schema="public" default-owner="postgres">
<role name="yuriy"
      superuser="true"
      inherit="true"
      login="true"
      encrypted="true"
      password="********">
</role>

<database name="main_db" encoding="UTF8" lc-collate="en_US.utf8" lc-ctype="en_US.utf8" is-template="false" allow-conns="true">
	<role name="yuriy"/>
	<tablespace name="pg_default"/>
</database>

<schema name="public" layer="0" rect-visible="true" fill-color="#e1e1e1" sql-disabled="true">
</schema>

<function name="setmactonull"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[
declare
    tableName alias for $1;
    query varchar;
begin
    query = 'alter table ' || tableName || ' set mac TO NULL';
    execute query;
    
    return 1;

    exception when OTHERS
              then
                    return 0;
end
]]></definition>
</function>

<function name="f_is_type_exist"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
  itypname alias for $1;
  tcount int4;
begin
  select count(typname) into tcount from pg_type where typname = itypname;
  return tcount;
end]]></definition>
</function>

<function name="f_safe_drop_type"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
  type_name alias for $1;
  tcount int4;
  dyn_query varchar;
begin
  select f_is_type_exist(type_name) into tcount;
  if(tcount > 0) then
    dyn_query := 'drop type ' || type_name || ' cascade';
    execute dyn_query;
    --drop type type_name;
    return true;
  end if;
  return false;
end]]></definition>
</function>

<function name="generateuid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="bigint" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    localId alias for $1;
    tableName alias for $2;

    orgUID varchar;
    theUID varchar;
    tName varchar;
    r record;
begin
    
    if(localId isnull or localId < 0 or tableName isnull) then
        return NULL;
    end if;

    orgUID = NULL;

    for r in
        select the_uid from getLocalOrg()
    loop
        orgUID := r.the_uid;
    end loop;

    if(substr(tableName, 1, 4) = 'tbl_') then
        tName = substr(tableName, 5);
    else
        tName = tableName;
    end if;
    
    --raise warning 'UNIQUE ID = %', orgUID;
    if(orgUID isnull) then
        orgUID = 'localorg';
    end if;

    theUID = orgUID || '-' || tName || '-' || localId;

    return theUID;

end]]></definition>
</function>

<function name="uidcheck"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY DEFINER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="1"/>
	</return-type>
	<definition><![CDATA[declare
    localId int8;
    tableName varchar;
    UID varchar;
    idUser int4;
    idObject int4;
    hasName bool;
    hasRName bool;
begin

    if(new.last_update isnull) then
        new.last_update = clock_timestamp();
    end if;

    if(TG_OP = 'UPDATE') then
        if(new.unique_id <> old.unique_id) then

            idUser = getCurrentUser();
            if(idUser = 2 or idUser = 1) then --jupiter and admin
                                                --we allow jupiter and admin to change UID of records and IO
                                                --but that must suggested as undeclared functionality (hack)
                return new;
            else
                raise exception 'You cannot change unique_id field of the record!';
                return NULL;
            end if;

        end if;

        tableName = TG_RELNAME;

        --raise exception 'rr_name = % --- name = %, tableName = %', new.rr_name, new.name, tableName;
        hasRName = f_is_column_exist(tableName, 'rr_name');--system qualifiers does not have field rr_name!
        if(hasRName is not null and hasRName = TRUE) then
     
            hasName = f_is_column_exist(tableName, 'name');

            if(hasName is not null and hasName = TRUE) then
                --raise exception 'rr_name = % --- name = %', new.rr_name, new.name;
                new.rr_name = new.name;
            end if;

            if(new.rr_name is null or new.rr_name = 'New record' or new.rr_name = 'Новая запись') then
                new.rr_name = 'Record ' || new.id;
           end if;

        end if;

        return new;
    end if;

    idUser = getCurrentUser();
    --raise notice 'CURRENT_USER = %', idUser;
    
    tableName = TG_RELNAME;--Здесь замену делвть не надо, поскольку sequence переименовывается всегда и называется, начиная с tbl_

    if(idUser = 2) then --jupiter (we insert the record that come from another organization)
        
        if(new.unique_id is not null) then
            hasRName = f_is_column_exist(tableName, 'rr_name');--system qualifiers does not have field rr_name!
            if(hasRName is not null and hasRName = TRUE) then
                if(new.rr_name isnull) then
                    new.rr_name = 'new record'; --при информационном обмене системные параметры записи будут обновлены позднее создания записи в таблице. 
                                                --Поэтому мы зададим произвольное значение полю rr_name. А оно потом будет автоматически обновлено до правильного
                end if;
            end if;

            return new;
        end if;
    end if;
    
--    if(new.unique_id is not null) then
        --raise notice 'User manually set value to unique_id field. Ignored! Will set autogenerated value!';
--    end if;

    if(new.id isnull) then --in ordinary case new.id canNOT be NULL
        select getNextSeq(tableName, 'id') into localId;
        new.id = localId;
    end if;

    localId = new.id;

    --select id into idObject from tbl_io_objects where table_name = tableName;-- system tables MUST have uid with localorg-XXX-XXX template
    --if(idObject < 300) then
    --    UID = 'localorg-' || tableName || '-' || localId;
    --else
        UID = generateUID(localId, tableName);
    --end if;

    if(UID isnull) then
        raise exception 'Cannot generate unique_id for the record! TABLE = %, LOCALID = %', tableName, localId;
        return NULL;
    end if;

    new.unique_id = UID;

    hasRName = f_is_column_exist(tableName, 'rr_name');--system qualifiers does not have field rr_name!
    if(hasRName is not null and hasRName = TRUE) then

        hasName = f_is_column_exist(tableName, 'name');

        if(hasName is not null and hasName = TRUE) then
            new.rr_name = new.name;
        end if;

        if(new.rr_name is null or new.rr_name = 'New record' or new.rr_name = 'Новая запись') then
            new.rr_name = 'Record ' || new.id;
       end if;

    end if;

    --в качестве кода атрибута, когда он не задан (NULL) или когда пуст (length(code) = 0), всегда используем UID. 
    --Это позволяет всегда иметь код атрибута (т.е. в т.ч. название колонки в таблицах справочников)
    --уникальными (в т.ч. и в случае информационного обмена)
    if(tableName = 'attributes') then
        --if(new.id >= 300) then
            if(new.code isnull or length(new.code) = 0) then
                new.code = new.unique_id;
            end if;
        --end if;    
    end if;

    return new;
end]]></definition>
</function>

<function name="createtriggeruid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    tableName alias for $1;
    query varchar;
begin

    --select f_safe_drop_trigger('trgsetuid', tableName);

    query = 'create trigger trgSetUID
             before insert or update
             on ' || tableName || '
             for each row 
             execute procedure uidCheck();';

    execute query;

    return 1;
end]]></definition>
</function>

<function name="createtriggeruidex"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[
declare
    tableName alias for $1;
    query varchar;
begin

    perform f_safe_drop_trigger('trgsetuid', tableName);

    query := 'create trigger trgsetuid
              before insert or update
              on ' || tableName || '
              for each row 
              execute procedure uidCheck();';

    execute query;

    return 1;
end
]]></definition>
</function>

<function name="uuid_nil"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="uuid" length="1"/>
	</return-type>
	<definition library="$libdir/uuid-ossp" symbol="uuid_nil"/>
</function>

<function name="uuid_ns_dns"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="uuid" length="1"/>
	</return-type>
	<definition library="$libdir/uuid-ossp" symbol="uuid_ns_dns"/>
</function>

<function name="uuid_ns_url"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="uuid" length="1"/>
	</return-type>
	<definition library="$libdir/uuid-ossp" symbol="uuid_ns_url"/>
</function>

<function name="uuid_ns_oid"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="uuid" length="1"/>
	</return-type>
	<definition library="$libdir/uuid-ossp" symbol="uuid_ns_oid"/>
</function>

<function name="uuid_ns_x500"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="uuid" length="1"/>
	</return-type>
	<definition library="$libdir/uuid-ossp" symbol="uuid_ns_x500"/>
</function>

<function name="uuid_generate_v1"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="uuid" length="1"/>
	</return-type>
	<definition library="$libdir/uuid-ossp" symbol="uuid_generate_v1"/>
</function>

<function name="uuid_generate_v1mc"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="uuid" length="1"/>
	</return-type>
	<definition library="$libdir/uuid-ossp" symbol="uuid_generate_v1mc"/>
</function>

<function name="uuid_generate_v3"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="uuid" length="1"/>
	</return-type>
	<parameter name="namespace">
		<type name="uuid" length="0"/>
	</parameter>
	<parameter name="name">
		<type name="text" length="0"/>
	</parameter>
	<definition library="$libdir/uuid-ossp" symbol="uuid_generate_v3"/>
</function>

<function name="uuid_generate_v4"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="uuid" length="1"/>
	</return-type>
	<definition library="$libdir/uuid-ossp" symbol="uuid_generate_v4"/>
</function>

<function name="uuid_generate_v5"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="uuid" length="1"/>
	</return-type>
	<parameter name="namespace">
		<type name="uuid" length="0"/>
	</parameter>
	<parameter name="name">
		<type name="text" length="0"/>
	</parameter>
	<definition library="$libdir/uuid-ossp" symbol="uuid_generate_v5"/>
</function>

<function name="normal_rand"
		window-func="false"
		returns-setof="true"
		behavior-type="STRICT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="1000">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="double precision" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="double precision" length="0"/>
	</parameter>
	<parameter name="_param3">
		<type name="double precision" length="0"/>
	</parameter>
	<definition library="$libdir/tablefunc" symbol="normal_rand"/>
</function>

<function name="crosstab"
		window-func="false"
		returns-setof="true"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="1000">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="record" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="text" length="0"/>
	</parameter>
	<definition library="$libdir/tablefunc" symbol="crosstab"/>
</function>

<usertype name="tablefunc_crosstab_2" configuration="composite">
	<schema name="public"/>
	<role name="yuriy"/>
	<typeattrib name="category_2">
		<type name="text" length="0"/>
	</typeattrib>
	<typeattrib name="category_1">
		<type name="text" length="0"/>
	</typeattrib>
	<typeattrib name="row_name">
		<type name="text" length="0"/>
	</typeattrib>
</usertype>

<usertype name="tablefunc_crosstab_3" configuration="composite">
	<schema name="public"/>
	<role name="yuriy"/>
	<typeattrib name="category_3">
		<type name="text" length="0"/>
	</typeattrib>
	<typeattrib name="category_2">
		<type name="text" length="0"/>
	</typeattrib>
	<typeattrib name="category_1">
		<type name="text" length="0"/>
	</typeattrib>
	<typeattrib name="row_name">
		<type name="text" length="0"/>
	</typeattrib>
</usertype>

<usertype name="tablefunc_crosstab_4" configuration="composite">
	<schema name="public"/>
	<role name="yuriy"/>
	<typeattrib name="category_4">
		<type name="text" length="0"/>
	</typeattrib>
	<typeattrib name="category_3">
		<type name="text" length="0"/>
	</typeattrib>
	<typeattrib name="category_2">
		<type name="text" length="0"/>
	</typeattrib>
	<typeattrib name="category_1">
		<type name="text" length="0"/>
	</typeattrib>
	<typeattrib name="row_name">
		<type name="text" length="0"/>
	</typeattrib>
</usertype>

<function name="crosstab2"
		window-func="false"
		returns-setof="true"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="1000">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="public.tablefunc_crosstab_2" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="text" length="0"/>
	</parameter>
	<definition library="$libdir/tablefunc" symbol="crosstab"/>
</function>

<function name="crosstab3"
		window-func="false"
		returns-setof="true"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="1000">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="public.tablefunc_crosstab_3" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="text" length="0"/>
	</parameter>
	<definition library="$libdir/tablefunc" symbol="crosstab"/>
</function>

<function name="crosstab4"
		window-func="false"
		returns-setof="true"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="1000">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="public.tablefunc_crosstab_4" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="text" length="0"/>
	</parameter>
	<definition library="$libdir/tablefunc" symbol="crosstab"/>
</function>

<function name="crosstab"
		window-func="false"
		returns-setof="true"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="1000">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="record" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="integer" length="0"/>
	</parameter>
	<definition library="$libdir/tablefunc" symbol="crosstab"/>
</function>

<function name="crosstab"
		window-func="false"
		returns-setof="true"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="1000">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="record" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="text" length="0"/>
	</parameter>
	<definition library="$libdir/tablefunc" symbol="crosstab_hash"/>
</function>

<function name="connectby"
		window-func="false"
		returns-setof="true"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="1000">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="record" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param3">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param4">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param5">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="_param6">
		<type name="text" length="0"/>
	</parameter>
	<definition library="$libdir/tablefunc" symbol="connectby_text"/>
</function>

<function name="connectby"
		window-func="false"
		returns-setof="true"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="1000">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="record" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param3">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param4">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param5">
		<type name="integer" length="0"/>
	</parameter>
	<definition library="$libdir/tablefunc" symbol="connectby_text"/>
</function>

<function name="connectby"
		window-func="false"
		returns-setof="true"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="1000">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="record" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param3">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param4">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param5">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param6">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="_param7">
		<type name="text" length="0"/>
	</parameter>
	<definition library="$libdir/tablefunc" symbol="connectby_text_serial"/>
</function>

<function name="connectby"
		window-func="false"
		returns-setof="true"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="1000">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="c" sql-disabled="true"/>
	<return-type>
	<type name="record" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param3">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param4">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param5">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param6">
		<type name="integer" length="0"/>
	</parameter>
	<definition library="$libdir/tablefunc" symbol="connectby_text_serial"/>
</function>

<extension name="postgis" cur-version="3.0.0">
	<schema name="public"/>
	<comment><![CDATA[PostGIS geometry, geography, and raster spatial types and functions]]></comment>
</extension>

<sequence name="tbl_communication_types_id_seq" cycle="false" start="1" increment="1" min-value="1" max-value="2147483647" cache="1">
	<schema name="public"/>
	<role name="postgres"/>
</sequence>

<table name="tbl_communication_types" layer="0" collapse-mode="2" max-obj-count="6" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="60" y="60"/>
	<column name="id" not-null="true" sequence="public.tbl_communication_types_id_seq">
		<type name="integer" length="0"/>
	</column>
	<column name="name_en" not-null="true">
		<type name="character varying" length="0"/>
	</column>
	<column name="name_ru" not-null="true">
		<type name="character varying" length="0"/>
	</column>
	<column name="description_en">
		<type name="character varying" length="0"/>
	</column>
	<column name="description_ru">
		<type name="character varying" length="0"/>
	</column>
	<constraint name="tbl_communication_types_pk" type="pk-constr" table="public.tbl_communication_types">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<usertype name="geometry" configuration="base"
 internal-length="0" by-value="false"
 alignment="double precision" storage="main"
 delimiter=":"
 category="U" sql-disabled="true">
	<schema name="public"/>
	<role name="yuriy"/>
	<comment><![CDATA[postgis type: The type representing spatial features with planar coordinate systems.]]></comment>
</usertype>

<sequence name="tbl_communications_id_seq" cycle="false" start="1" increment="1" min-value="1" max-value="2147483647" cache="1">
	<schema name="public"/>
	<role name="postgres"/>
</sequence>

<table name="tbl_communications" layer="0" collapse-mode="2" max-obj-count="7" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="440" y="60"/>
	<column name="id" not-null="true" sequence="public.tbl_communications_id_seq">
		<type name="integer" length="0"/>
	</column>
	<column name="id_parent">
		<type name="integer" length="0"/>
	</column>
	<column name="name" not-null="true">
		<type name="character varying" length="0"/>
	</column>
	<column name="description">
		<type name="character varying" length="0"/>
	</column>
	<column name="id_type" not-null="true">
		<type name="integer" length="0"/>
	</column>
	<column name="geo_location">
		<type name="public.geometry" length="0"/>
	</column>
	<constraint name="tbl_communications_pk" type="pk-constr" table="public.tbl_communications">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<function name="checkformaclabeltype"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<definition><![CDATA[declare
    isExist int4;
begin

    select f_is_type_exist('maclabel') into isExist;
    if(isExist > 0) then
        return 1;
    end if;
    
    create type maclabel as(m1 int4, m2 int4);
    
    return 2;

end]]></definition>
</function>

<usertype name="maclabel" configuration="composite">
	<schema name="public"/>
	<role name="yuriy"/>
	<typeattrib name="m2">
		<type name="integer" length="0"/>
	</typeattrib>
	<typeattrib name="m1">
		<type name="integer" length="0"/>
	</typeattrib>
</usertype>

<sequence name="maclabels_id_seq" cycle="false" start="1" increment="1" min-value="1" max-value="2147483647" cache="1">
	<schema name="public"/>
	<role name="yuriy"/>
</sequence>

<table name="maclabels" layer="0" collapse-mode="2" max-obj-count="3" z-value="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<position x="780" y="60"/>
	<column name="id" not-null="true" sequence="public.maclabels_id_seq">
		<type name="integer" length="0"/>
	</column>
	<column name="name" not-null="true">
		<type name="character varying" length="0"/>
	</column>
	<column name="mac_value" not-null="true">
		<type name="public.maclabel" length="0"/>
	</column>
	<constraint name="pk_maclabels" type="pk-constr" table="public.maclabels">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<function name="f_is_table_exist"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
  itablename alias for $1;
  iSchemaName alias for $2;

  tcount int4;
  vSchemaName varchar;
begin
  if(iSchemaName isnull or iSchemaName = '') then
      vSchemaName = 'public';
  else
      vSchemaName = iSchemaName;
  end if;

  select count(tablename) into tcount from pg_tables where tablename = itablename and schemaname = vSchemaName ;

  return tcount;

end]]></definition>
</function>

<function name="f_is_temp_table_exist"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
  itablename alias for $1;
  tcount int4;
  q varchar;
begin

  q = 'create temp table ' || itablename || ' (id int4)';
  execute q;

  q = 'drop table ' || itablename;
  execute q;

  return 0;

EXCEPTION
        WHEN duplicate_table THEN
            RETURN 1;
end]]></definition>
</function>

<function name="f_is_view_exist"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
  iviewname alias for $1;
  tcount int4;
begin
  select count(viewname) into tcount from pg_views where viewname = iviewname and schemaname = 'public';
  return tcount;
end]]></definition>
</function>

<function name="f_is_column_exist"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[
declare
    tableName alias for $1;
    columnName alias for $2;

    attCount int4;
begin

    select count(a.attname)  into attCount
    from
        pg_class c,
        pg_attribute a
    where
        c.oid = a.attrelid
        and c.relname = tableName
        and a.attname = columnName;   

    if(attCount >= 1) then
        return TRUE;
    else
        return FALSE;
    end if;

    return FALSE;
    
    exception when others then
        return FALSE;

end
]]></definition>
</function>

<function name="f_is_index_exist"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[
declare
    indexName alias for $1;

    iCount int4;
begin

    select count(pgi.indexname)  into iCount
    from
        pg_indexes pgi
    where
        pgi.indexname = indexName;

    if(iCount >= 1) then
        return TRUE;
    else
        return FALSE;
    end if;

    return FALSE;
    
    exception when others then
        return FALSE;

end
]]></definition>
</function>

<function name="f_is_table_has_parent"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    tChild alias for $1;
    tParent alias for $2;

    r record;
    ok bool;
begin

    for r in 
        select c2.relname
        from 
            pg_inherits h,
            pg_class c1,
            pg_class c2
        where 
            c1.relname = tChild
            and c1.oid = h.inhrelid
            and h.inhparent = c2.oid
    loop
        if(r.relname = tParent) then
            return true;
        end if;

        ok := f_is_table_has_parent(r.relname::varchar, tParent);
        if(ok = true) then
            return true;
        end if;
    end loop;

    return false;

end]]></definition>
</function>

<function name="f_is_seq_exist"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
  iseqname alias for $1;
  tcount int4;
begin
  select count(relname) into tcount from pg_class where relname = iseqname and relkind = 'S';
  return tcount;
end]]></definition>
</function>

<function name="f_inc_table_column"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="bigint" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param3">
		<type name="bigint" length="0"/>
	</parameter>
	<definition><![CDATA[
declare
    tableName alias for $1;
    columnName alias for $2;
    keyVal alias for $3;

    newVal int8;
    seqName varchar;
    bExist int4;
    ok int4;
    q varchar;
    r record;
    startVal int4;
begin

    seqName = tableName || '_' || columnName || '_' || 'inc_seq';

    bExist = f_is_seq_exist(seqName);
    if(bExist = 0) then

        q = E'select "' || columnName || E'" as startVal from ' || tableName || ' where id = ' || keyVal;
        startVal = -1;
        for r in execute q
        loop
            startVal = r.startVal;
             if(startVal isnull) then
                 startVal = 0;
             end if;
        end loop;

        if(startVal = -1) then
            raise exception 'there is no record with key value = %', keyVal;
            return -1;
        end if; 

        q = E'create sequence "' || seqName || E'" start with ' || startVal+1;
        execute q;

    end if;

    select nextval(seqName) into newVal;

    q = E'update ' || tableName || ' set "' || columnName || '" = ' || newVal || ' where id = ' || keyVal;
    execute q;
  
    return newVal;

end
]]></definition>
</function>

<function name="f_create_trigger"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param3">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param4">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param5">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[
declare
    trgName alias for $1;
    trgWhen alias for $2; --before after
    trgActions alias for $3; --insert or update or delete
    tableName alias for $4;
    trgProcName alias for $5;

    query varchar;
    rTableName varchar;
    isExist int4;
begin
    if(trgName isnull or trgWhen isnull or trgActions isnull or tableName isnull or trgProcName isnull) then
        return 0;
    end if;

    select f_is_table_exist(tableName, NULL) into isExist; 
    if(isExist = 1) then
        rTableName := tableName;
    else
        select f_is_table_exist('tbl_' || tableName, NULL) into isExist; 
        if(isExist = 1) then
            rTableName := 'tbl_' || tableName;
        else
            raise exception 'Table % is corrupted! Cannot create trigger on it!', tableName;
            return 0;
        end if;
    end if;


    query = 'create trigger ' || trgName || ' ' || trgWhen || ' ' || trgActions || ' on ' || rTableName || ' for each row execute procedure ' || trgProcName;
    execute query;
    
    return 1;

end
]]></definition>
</function>

<function name="f_create_trigger"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param3">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param4">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param5">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param6">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[
declare
    trgName alias for $1;
    trgWhen alias for $2; --before after
    trgActions alias for $3; --insert or update or delete
    tableName alias for $4;
    schemaName alias for $5;
    trgProcName alias for $6;

    query varchar;
    rTableName varchar;
    isExist int4;
begin
    if(trgName isnull or trgWhen isnull or trgActions isnull or tableName isnull or trgProcName isnull) then
        return 0;
    end if;

    select f_is_table_exist(tableName, schemaName) into isExist; 
    if(isExist = 1) then
        rTableName := tableName;
    else
        select f_is_table_exist('tbl_' || tableName, schemaName) into isExist; 
        if(isExist = 1) then
            rTableName := 'tbl_' || tableName;
        else
            raise exception 'Table % is corrupted! Cannot create trigger on it!', tableName;
            return 0;
        end if;
    end if;


    query = 'create trigger ' || trgName || ' ' || trgWhen || ' ' || trgActions || ' on ' || rTableName || ' for each row execute procedure ' || trgProcName;
    execute query;
    
    return 1;

end
]]></definition>
</function>

<function name="f_enable_trigger"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param3">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    tableName alias for $1;
    triggerName alias for $2;
    bEnable alias for $3;
    q varchar;
begin

    if(bEnable = false) then
        q = 'alter table ' || tableName || ' disable trigger ' || triggerName;
    else
        q = 'alter table ' || tableName || ' enable trigger ' || triggerName;
    end if;

    execute q;

    return 1;
end]]></definition>
</function>

<function name="f_enable_triggers"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<parameter name="_param3">
		<type name="character varying" length="0" dimension="1"/>
	</parameter>
	<definition><![CDATA[declare
    tableName alias for $1;
    bEnable alias for $2;
    tExclude alias for $3; --исключить из списка

    r record;
begin

    for r in 
        select 
            t.tgname 
        from 
            pg_trigger t, 
	    pg_class c 
        where 
            t.tgrelid = c.oid
            and c.relname = tableName
            and t.tgisinternal = false
            and case when tExclude isnull then 1=1 else t.tgname <> ANY (tExclude) end
    loop
        perform f_enable_trigger(tableName, r.tgname::varchar, bEnable);
    end loop;

    return 1;
end]]></definition>
</function>

<function name="f_safe_drop_table"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
  table_name alias for $1;
  tcount int4;
  dyn_query varchar;
begin
  select f_is_table_exist(table_name, NULL) into tcount;
  if(tcount > 0) then
    dyn_query := 'drop table ' || table_name || ' cascade';
    execute dyn_query;
    --drop table table_name;
    return true;
  end if;
  return false;
end]]></definition>
</function>

<function name="f_safe_drop_table"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
  table_name alias for $1;
  schemaName alias for $2;

  tcount int4;
  dyn_query varchar;
begin
  select f_is_table_exist(table_name, schemaName) into tcount;
  if(tcount > 0) then
    dyn_query := 'drop table ' || table_name || ' cascade';
    execute dyn_query;
    --drop table table_name;
    return true;
  end if;
  return false;
end]]></definition>
</function>

<function name="f_safe_drop_trigger"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    trgName alias for $1;
    tableName alias for $2;
    
    cnt int4;
    query varchar;
    isExist int4;
    rTableName varchar;
begin

    if(trgName isnull or tableName isnull) then
        return 0;
    end if;

    select f_is_table_exist(tableName, NULL) into isExist; 
    if(isExist = 1) then
        rTableName := tableName;
    else
        select f_is_table_exist('tbl_' || tableName, NULL) into isExist; 
        if(isExist = 1) then
            rTableName := 'tbl_' || tableName;
        else
            raise exception 'Table % is corrupted! Cannot drop trigger on it!', tableName;
            return 0;
        end if;
    end if;


    select 
        count(c.relname) into cnt 
    from 
        pg_trigger t, 
	pg_class c 
    where 
        t.tgname = trgName 
	and t.tgrelid = c.oid
	and c.relname = rTableName;
	
    if(cnt > 0) then
        query := 'drop trigger ' || trgName || ' on ' || rTableName;
        execute query;
    end if;

    return 1;    

end]]></definition>
</function>

<function name="f_safe_drop_trigger"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param3">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    trgName alias for $1;
    tableName alias for $2;
    schemaName alias for $3;
    
    cnt int4;
    query varchar;
    isExist int4;
    rTableName varchar;
begin

    if(trgName isnull or tableName isnull) then
        return 0;
    end if;

    select f_is_table_exist(tableName, schemaName) into isExist; 
    if(isExist = 1) then
        rTableName := tableName;
    else
        select f_is_table_exist('tbl_' || tableName, schemaName) into isExist; 
        if(isExist = 1) then
            rTableName := 'tbl_' || tableName;
        else
            raise exception 'Table % is corrupted! Cannot drop trigger on it!', tableName;
            return 0;
        end if;
    end if;


    select 
        count(c.relname) into cnt 
    from 
        pg_trigger t, 
	pg_class c 
    where 
        t.tgname = trgName 
	and t.tgrelid = c.oid
	and c.relname = rTableName;
	
    if(cnt > 0) then
        query := 'drop trigger ' || trgName || ' on ' || rTableName;
        execute query;
    end if;

    return 1;    

end]]></definition>
</function>

<function name="f_safe_drop_view"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    view_name alias for $1;
    tcount int4;
    dyn_query varchar;
begin

    select f_is_view_exist(view_name) into tcount;
    if(tcount > 0) then
        dyn_query := 'drop view ' || view_name || ' cascade';
        execute dyn_query;
        return true;
    end if;
  
    return false;
end]]></definition>
</function>

<function name="f_safe_drop_index"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
  indexName alias for $1;
  tcount int4;
  dyn_query varchar;
begin
  select f_is_index_exist(indexName) into tcount;
  if(tcount > 0) then
    dyn_query := 'drop index ' || indexName || ' ';
    execute dyn_query;
    --drop type type_name;
    return true;
  end if;
  return false;
end]]></definition>
</function>

<function name="f_set_all_schemas_visible"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<definition><![CDATA[
declare
    r record;
    q varchar;
begin

    q = 'set search_path to public';
    for r in 
        select nspname from pg_namespace where nspname not like ('pg_%') and nspname <> 'information_schema' and nspname <> 'public'
    loop
        q = q || ', ' || r.nspname;
    end loop;

    execute q;
    raise warning '%', q;

    return 1;
end
]]></definition>
</function>

<function name="createtableconnkey"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<definition><![CDATA[declare

begin

    create temp table conn_key (connection_key varchar null);
    
    return 1;
end
]]></definition>
</function>

<function name="getconnectionkey"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<definition><![CDATA[declare

   Key VARCHAR;

begin

    select connection_key into Key from conn_key;

    return Key;
end
]]></definition>
</function>

<function name="setconnectionkey"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare

    Key alias for $1;

    tmp varchar;
begin

    select connection_key into tmp from conn_key;

    if (tmp IS NOT NULL) then

        return -1;

    else

        insert into conn_key select Key;

    end if;

    return 1;
end
]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    needQuote alias for $2;
    string varchar;

begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    string := '' || num;
    
    if(needQuote = TRUE) then
        return quote_literal(string);
    end if;

    return string;
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="bigint" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    needQuote alias for $2;
    string varchar;
begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    string := '' || num;

    if(needQuote = TRUE) then
        return quote_literal(string);
    end if;
    
    return string;
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="uuid" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    needQuote alias for $2;
    string varchar;
begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    string := '' || num;

    if(needQuote = TRUE) then
        return quote_literal(string);
    end if;
    
    return string;
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="integer" length="0" dimension="1"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    nums alias for $1;
    need_quote alias for $2;
begin
    if(nums isnull) then
	return 'NULL';
    end if;
    
    if(need_quote = true) then
        return quote_literal('{' || array_to_string(nums, ',') || '}');
    end if;

    return '{' || array_to_string(nums, ',') || '}';
    
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="bigint" length="0" dimension="1"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    nums alias for $1;
    need_quote alias for $2;
begin
    if(nums isnull) then
	return 'NULL';
    end if;
    
    if(need_quote = true) then
        return quote_literal('{' || array_to_string(nums, ',') || '}');
    end if;

    return '{' || array_to_string(nums, ',') || '}';
    
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="double precision" length="0" dimension="1"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    nums alias for $1;
    need_quote alias for $2;
begin
    if(nums isnull) then
	return 'NULL';
    end if;
    
    if(need_quote = true) then
        return quote_literal('{' || array_to_string(nums, ',') || '}');
    end if;

    return '{' || array_to_string(nums, ',') || '}';
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0" dimension="1"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    nums alias for $1;
    need_quote alias for $2;
begin
    if(nums isnull) then
	return 'NULL';
    end if;
    
    if(need_quote = true) then
        return quote_literal('{' || array_to_string(nums, '~^~') || '}');
    end if;

    return '{' || array_to_string(nums, '~^~') || '}';
end]]></definition>
</function>

<function name="asstring1"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0" dimension="1"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    nums alias for $1;
    need_quote alias for $2;
begin
    if(nums isnull) then
	return '';
    end if;
    
    if(need_quote = true) then
        return quote_literal(array_to_string(nums, ''));
    end if;

    return array_to_string(nums, '');
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="double precision" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    string varchar;
begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    string := ' ' || num;
    return ltrim(string);
    
    return string;
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="timestamp" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    need_quote alias for $2;
    string varchar;
begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    string := '' || num;
    --return ltrim(string);
    if(need_quote = true) then
        return quote_literal(string);
    end if;
    
    return string;
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="date" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    need_quote alias for $2;
    string varchar;
begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    string := '' || num;
    --return ltrim(string);
    if(need_quote = true) then
        return quote_literal(string);
    end if;
    
    return string;
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="time" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    need_quote alias for $2;
    string varchar;
begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    string := '' || num;
    --return ltrim(string);
    if(need_quote = true) then
        return quote_literal(string);
    end if;
    
    return string;
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="time with time zone" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    need_quote alias for $2;
    string varchar;
begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    string := '' || num;
    --return ltrim(string);
    if(need_quote = true) then
        return quote_literal(string);
    end if;
    
    return string;
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="interval" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    need_quote alias for $2;
    string varchar;
begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    string := '' || num;
    --return ltrim(string);
    if(need_quote = true) then
        return quote_literal(string);
    end if;
    
    return string;
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="boolean" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    string varchar;
begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    if(num = TRUE) then
	string := 'TRUE';
    else 
	string := 'FALSE';
    end if;

    return string;
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    need_quote alias for $2;
begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    if(need_quote = true) then
        return quote_literal(num);
    end if;

    return num;
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    need_quote alias for $2;
begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    if(need_quote = true) then
        return quote_literal(num::varchar);
    end if;
    return num::varchar;
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="xml" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    need_quote alias for $2;
begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    if(need_quote = true) then
        return quote_literal(num::varchar);
    end if;

    return num::varchar;
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="bytea" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    need_quote alias for $2;
begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    if(need_quote = true) then
        return quote_literal(num::varchar);
    end if;

    return num::varchar;
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="public.geometry" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    need_quote alias for $2;
    sGeom varchar;
begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    sGeom := st_asEwkt(num);

    if(need_quote = true) then
        return quote_literal(sGeom);
    end if;

    return sGeom;
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="bit" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    need_quote alias for $2;
    isrid int4;
begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    if(need_quote = true) then
        return quote_literal(bit_to_text(num)::varchar);
    end if;

    return bit_to_text(num)::varchar;
end]]></definition>
</function>

<function name="asstring"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="public.maclabel" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    num alias for $1;
    needQuote alias for $2;
    string varchar;
begin
    if(num isnull) then
	return 'NULL';
    end if;
    
    string := '' || num;

    if(needQuote = TRUE) then
        return quote_literal(string);
    end if;
    
    return string;
end]]></definition>
</function>

<function name="isnumeric"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="text" length="0"/>
	</parameter>
	<definition><![CDATA[declare
	iString alias for $1;
	ok bool;
begin

	select textregexeq(iString,E'^[[:digit:]]+(\.[[:digit:]]+)?$') into ok;
	return ok;

end]]></definition>
</function>

<function name="isinteger"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="text" length="0"/>
	</parameter>
	<definition><![CDATA[declare
	iString alias for $1;
	ok bool;
begin

	select textregexeq(iString,E'^[[:digit:]]+(\.[[:digit:]]+)?$') into ok;
	return ok;

end]]></definition>
</function>

<function name="to_int4"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
       i int4;
begin
       i := $1::int4;
       return i;

       EXCEPTION WHEN 
                    invalid_text_representation or 
                    numeric_value_out_of_range 
                 then
                    return NULL;
                 when OTHERS
                 then 
                    return NULL;
end;]]></definition>
</function>

<function name="to_int8"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="bigint" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
       i int8;
begin
       i := $1::int8;
       return i;

       EXCEPTION WHEN 
                    invalid_text_representation or 
                    numeric_value_out_of_range 
                 then
                    return NULL;
                 when OTHERS
                 then 
                    return NULL;
end;]]></definition>
</function>

<function name="to_float8"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="double precision" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
       i float8;
begin
       i := $1::float8;
       return i;

       EXCEPTION WHEN 
                    invalid_text_representation or 
                    numeric_value_out_of_range 
                 then
                    return NULL;
                 when OTHERS
                 then 
                    return NULL;
end;]]></definition>
</function>

<function name="to_timestamp"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="timestamp" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
       i timestamp;
begin
       i := $1::timestamp;
       return i;

       EXCEPTION WHEN 
                    invalid_text_representation or 
--                    datetime_value_out_of_range or
                    invalid_datetime_format
                 then
                    return NULL;
                 when OTHERS
                 then 
                    return NULL;
end;]]></definition>
</function>

<function name="to_time"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="time" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
       i time;
begin
       i := $1::time;
       return i;

       EXCEPTION WHEN 
                    invalid_text_representation or 
--                    datetime_value_out_of_range or
                    invalid_datetime_format
                 then
                    return NULL;
                 when OTHERS
                 then 
                    return NULL;
end;]]></definition>
</function>

<function name="to_date"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="date" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
       i date;
begin
       i := $1::date;
       return i;

       EXCEPTION WHEN 
                    invalid_text_representation or 
--                    datetime_value_out_of_range or
                    invalid_datetime_format
                 then
                    return NULL;
                 when OTHERS
                 then 
                    return NULL;
end;]]></definition>
</function>

<function name="checklasterrortable"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="1"/>
	</return-type>
	<definition><![CDATA[declare
    cnt int4;
begin

    select f_is_temp_table_exist('last_error') into cnt;
    if(cnt = 0) then
        perform createLastErrorTable();
    end if;
    
    return;
    
end]]></definition>
</function>

<function name="setlasterrordata"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    errData alias for $1;
begin
    
    perform checkLastErrorTable();

    update last_error
    set error_data = errData;
        
    return;
    
--    exception when 
--                    undefined_table
--              then
--                    perform createLastErrorTable();
--                    
--                    perform setLastErrorData(errData);
--                    return;
end]]></definition>
</function>

<function name="updatelasterror"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    sql_state alias for $1;
    sql_errm  alias for $2;
    
    r RECORD;
    undef_error_name varchar;
    undef_error_code char(5);
begin
    
    undef_error_name := 'undefined error';
    undef_error_code := 'U0000';
    
    perform checkLastErrorTable();

    for r in
        select 
            err.sqlstate, 
            err.name, 
            err.id_group, 
            errg.name as group_name
        from 
            error err, 
            group_error errg 
        where 
            err.sqlstate = sql_state 
            and err.id_group = errg.id_group
    loop
        if(r.sqlstate isnull) then
            --insert into last_error values(undef_error_code, undef_error_name, sql_errm, NULL, NULL);
            update last_error 
            set 
                error_name = undef_error_name, 
                error_sqlstate = undef_error_code, 
                error_message = sql_errm, 
                error_group = NULL, 
                error_group_name = NULL, 
                error_data = NULL;
            return;
        end if;

        --insert into last_error values(r.sqlstate, r.name, sql_errm, r.id_group, r.group_name); 
        update last_error 
        set 
            error_name = r.name, 
            error_sqlstate = r.sqlstate, 
            error_message = sql_errm, 
            error_group = r.id_group, 
            error_group_name = r.group_name, 
            error_data = NULL;
        return;
    end loop;
    
    --insert into last_error values(undef_error_code, undef_error_name, sql_errm, NULL, NULL);
    update last_error 
    set 
        error_name = undef_error_name, 
        error_sqlstate = undef_error_code, 
        error_message = sql_errm, 
        error_group = NULL, 
        error_group_name = NULL, 
        error_data = NULL;
    
    return;
    
--    exception when 
--                    undefined_table
--              then
--                    perform createLastErrorTable();
--                    
--                    perform updateLastError(sql_state, sql_errm);
--                    return;
end]]></definition>
</function>

<function name="clearlasterror"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="1"/>
	</return-type>
	<definition><![CDATA[begin
    --truncate last_error;
    --insert into last_error values('00000', 'SUCCESSFUL COMPLETION', 'SUCCESSFUL COMPLETION', 1, 'SUCCESSFUL COMPLETION');

    perform checkLastErrorTable();
    
    update last_error set 
            error_name = 'SUCCESSFUL COMPLETION', 
            error_sqlstate = '00000', 
            error_message = 'SUCCESSFUL COMPLETION', 
            error_group = 1, 
            error_group_name = 'SUCCESSFUL COMPLETION',
            error_data = NULL;
    
    return;
    
--    exception when 
--                    undefined_table
--              then
--                    perform createLastErrorTable();
--                    
--                    perform clearLastError();
--                    return;
end]]></definition>
</function>

<usertype name="h_get_last_error" configuration="composite">
	<schema name="public"/>
	<role name="yuriy"/>
	<typeattrib name="error_group">
		<type name="integer" length="0"/>
	</typeattrib>
	<typeattrib name="error_sqlstate">
		<type name="character" length="5"/>
		<collation name="pg_catalog.&quot;default&quot;"/>
	</typeattrib>
	<typeattrib name="error_data">
		<type name="character varying" length="0"/>
		<collation name="pg_catalog.&quot;default&quot;"/>
	</typeattrib>
	<typeattrib name="error_group_name">
		<type name="character varying" length="0"/>
		<collation name="pg_catalog.&quot;default&quot;"/>
	</typeattrib>
	<typeattrib name="error_message">
		<type name="character varying" length="0"/>
		<collation name="pg_catalog.&quot;default&quot;"/>
	</typeattrib>
	<typeattrib name="error_name">
		<type name="character varying" length="0"/>
		<collation name="pg_catalog.&quot;default&quot;"/>
	</typeattrib>
</usertype>

<function name="getlasterror"
		window-func="false"
		returns-setof="true"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="1000">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="public.h_get_last_error" length="1"/>
	</return-type>
	<definition><![CDATA[declare
    r h_get_last_error%rowtype;
begin

    perform checkLastErrorTable();
    
    for r in 
        select * from last_error limit 1
    loop
        return next r;
        return;
    end loop;
    
    return;

--    exception when 
--                    undefined_table
--              then
--                    perform createLastErrorTable();
--                    
--                    for r in 
--                        select * from getLastError()
--                    loop
--                        return next r;
--                    end loop;
--                    return;
end]]></definition>
</function>

<function name="getlasterrorcode"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character" length="1"/>
	</return-type>
	<definition><![CDATA[declare
    err_code char(5);
begin
    
    perform checkLastErrorTable();
    
    select error_sqlstate into err_code from last_error limit 1;
    
    return err_code;
    
--    exception when 
--                    undefined_table
--              then
--                    perform createLastErrorTable();
--                    return getLastErrorCode();
end]]></definition>
</function>

<function name="createlasterrortable"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="1"/>
	</return-type>
	<definition><![CDATA[begin

    create temp table last_error 
    (
        ERROR_SQLSTATE       CHAR(5)              not null,
        ERROR_NAME           VARCHAR              not null,
        ERROR_MESSAGE        VARCHAR              null,
        ERROR_GROUP          INT4                 null,
        ERROR_GROUP_NAME     VARCHAR              null,
        ERROR_DATA           VARCHAR              null
    );

    insert into last_error values('00000', 'SUCCESSFUL COMPLETION', 'SUCCESSFUL COMPLETION', 1, 'SUCCESSFUL COMPLETION');
    
    return;
    
--    exception when OTHERS
--        then 
--            raise notice '%', sqlstate;
end]]></definition>
</function>

<function name="getnextseq"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="bigint" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    tableName alias for $1;
    pkName alias for $2;

    id int8;
    seqName varchar;
    seqTableName varchar;
    isExist int4;
begin
    perform clearLastError();

    if (tableName = 'units' or
        tableName = 'position' or
        tableName = 'users'
       ) then
        --seqName := 'kks_roles' || '_' || pkName || '_seq';
        seqTableName := 'kks_roles'; -- || '_' || pkName || '_seq';
    else
        if(substr(tableName, 1, 4) = 'tbl_' or
           tableName = 'rec_attrs_values' or
           tableName = 'attrs_values' 
          ) then
            --seqName := tableName || '_' || pkName || '_seq';
            seqTableName := tableName;-- || '_' || pkName || '_seq';
        else

            select f_is_view_exist(tableName) into isExist; --if view with given name is exist this means that the real table has name with prefix tbl_
            if(isExist = 1) then
                --seqName := 'tbl_' || tableName || '_' || pkName || '_seq';
                seqTableName := 'tbl_' || tableName;-- || '_' || pkName || '_seq';
            else
                --seqName := tableName || '_' || pkName || '_seq';                
                seqTableName := tableName;-- || '_' || pkName || '_seq';                
            end if;

        end if;
    end if;

    if(f_is_table_has_parent(seqTableName, 'q_base_table') = true) then
        seqTableName = 'q_base_table';
    end if;

    seqName = seqTableName || '_' || pkName || '_seq';
    select pg_catalog.nextval(seqName) into id;

    if(id isnull) then
        perform updateLastError('UNK0', 'Unknown error was occured');
        return -1;
    end if;
    
    return id;

--    exception when OTHERS
--
--              then 
--                   perform updateLastError(SQLSTATE, SQLERRM);
--                   return -1;
end]]></definition>
</function>

<function name="gis_patrol_version"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY DEFINER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<definition><![CDATA[declare
    ver varchar;
begin
    
    select version into ver from version_table;

    if(ver isnull) then
        raise warning 'Incorrect version of GIS PATROL SERVER!';
    end if;
    
    return ver;
    
end]]></definition>
</function>

<function name="gis_patrol_version1"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY DEFINER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<definition><![CDATA[declare
    ver varchar;
begin
    
    select short_version into ver from version_table;

    if(ver isnull) then
        raise warning 'Incorrect version of GIS PATROL SERVER!';
    end if;
    
    return ver;
    
end]]></definition>
</function>

<function name="setgis_patrol_version"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY DEFINER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="_param2">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    ver alias for $1;
    shortVer alias for $2;
begin
    
    perform f_safe_drop_table('version_table');

    create table version_table(version varchar, short_version varchar);

    insert into version_table(version, short_version) values(ver, shortVer);

    return 1;

end]]></definition>
</function>

<function name="getsystemparamstr"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY DEFINER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="integer" length="0"/>
	</parameter>
	<definition><![CDATA[
declare
    idSystem alias for $1;
    val varchar;
begin

    select str_parameter into val from system_table where id_system = idSystem;

    return val;

end
]]></definition>
</function>

<function name="getsystemparamint"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY DEFINER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="integer" length="0"/>
	</parameter>
	<definition><![CDATA[
declare
    idSystem alias for $1;
    val int4;
begin

    select int_parameter into val from system_table where id_system = idSystem;

    return val;

end
]]></definition>
</function>

<function name="getrecordtable"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY DEFINER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="bigint" length="0"/>
	</parameter>
	<definition><![CDATA[
declare
    idRecord alias for $1;

    tName1 varchar;
    tName2 varchar;


    idObject1 int4;
    idObject2 int4;

    pos int4;
begin

    SELECT p.relname into tName1
    FROM q_base_table q, pg_class p
    WHERE q.id = idRecord AND q.tableoid = p.oid;
    
    --в силу того, что мы "подменяем" таблицы представлениями и именно название представления записываем в поле table_name таблицы tbl_io_objects,
    --нам необходимо вернуть именно то название (таблицы или представления), которое записано в tbl_io_objects
    --поэтому мы должны проанализировать полученное в tName1 значение

    pos := position('tbl_' in tName1);
    if(pos = 1) then --если название физической таблицы начинается с tbl_ , то можно предположить, что в io_objects 
        tName2 := substring(tName1 from 5);
        if(char_length(tName2) = 0) then
            return tName1;
        end if;
    else --в этом случае в Io_objects хранится название физической таблицы (acl_secureTable() для нее не вызывалась)
        return tName1;
    end if;

    
    select id into idObject1 from tbl_io_objects where table_name = tName1; --именно так называется таблица. Но в tbl_io_objects может быть записано иное, поэтому делаем второй запрос
    select id into idObject2 from tbl_io_objects where table_name = tName2; --предположительно именно это записано в tbl_io_objects

    if(idObject1 is not null and idObject2 is not null) then
        return tName1;
    end if;

    if(idObject2 is not null) then
        return tName2;
    end if;

    return tName1;
end
]]></definition>
</function>

<function name="getmilliseconds"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="double precision" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="interval" length="0"/>
	</parameter>
	<definition><![CDATA[
declare
    iInt alias for $1;
    mSecs float8;
begin

    SELECT 
        ((60*(EXTRACT(HOURS FROM iInt))
        +
        EXTRACT(MINUTES FROM iInt) ) * 60
        +
        EXTRACT(SECOND FROM iInt) ) * 1000
    into mSecs;

    return mSecs;
end
]]></definition>
</function>

<function name="getseconds"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="double precision" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="interval" length="0"/>
	</parameter>
	<definition><![CDATA[
declare
    iInt alias for $1;
    mSecs float8;
begin

    SELECT 
        ((60*(EXTRACT(HOURS FROM iInt))
        +
        EXTRACT(MINUTES FROM iInt) ) * 60
        +
        EXTRACT(SECOND FROM iInt) )
    into mSecs;

    return mSecs;
end
]]></definition>
</function>

<function name="getprimarykey"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[
declare
    tableName alias for $1;
    pkName varchar;
    tName varchar;
    isExist int4;
begin

    if(substr(tableName, 1, 4) = 'tbl_' or
        tableName = 'rec_attrs_values' or
        tableName = 'attrs_values' 
      ) then
        tName := tableName;
    else

        select f_is_view_exist(tableName) into isExist; --if view with given name is exist this means that the real table has name with prefix tbl_
        if(isExist = 1) then
            tName := 'tbl_' || tableName;
        else
            tName := tableName;
        end if;

    end if;

    SELECT a.attname into pkName
    FROM 
        pg_class c, 
        pg_class c2, 
        pg_index i, 
        pg_attribute a
    WHERE 
        c.relname = tName 
        AND c.oid = i.indrelid 
        AND i.indexrelid = c2.oid
        AND i.indisprimary 
        AND i.indisunique 
        AND a.attrelid=c2.oid
        AND a.attnum>0
    LIMIT 1;

    return pkName;
end
]]></definition>
</function>

<function name="getprimarykeys"
		window-func="false"
		returns-setof="true"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="1000">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="character varying" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[
declare
    tableName alias for $1;
    pkName varchar;
    tName varchar;
    r record;
    isExist int4;
begin

    if(substr(tableName, 1, 4) = 'tbl_' or
        tableName = 'rec_attrs_values' or
        tableName = 'attrs_values' 
      ) then
        tName := tableName;
    else

        select f_is_view_exist(tableName) into isExist; --if view with given name is exist this means that the real table has name with prefix tbl_
        if(isExist = 1) then
            tName := 'tbl_' || tableName;
        else
            tName := tableName;
        end if;

    end if;



    for r in 
        SELECT a.attname
        FROM 
            pg_class c, 
            pg_class c2, 
            pg_index i, 
            pg_attribute a
        WHERE 
            c.relname = tName 
            AND c.oid = i.indrelid 
            AND i.indexrelid = c2.oid
            AND i.indisprimary 
            AND i.indisunique 
            AND a.attrelid=c2.oid
            AND a.attnum>0
    loop
        return next r.attname;
    end loop;

    return;
end
]]></definition>
</function>

<function name="f_clear_function"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<definition><![CDATA[
begin
    return 1;
end
]]></definition>
</function>

<function name="generateuuid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="uuid" length="1"/>
	</return-type>
	<definition><![CDATA[
declare
    
begin
    return uuid_generate_v1();
end
]]></definition>
</function>

<function name="uuidcheck"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="1"/>
	</return-type>
	<definition><![CDATA[
declare
    tableName varchar;
    uuid_t uuid;
begin

    if(new.uuid_t isnull) then
        new.uuid_t = generateUUID();
    end if;

    return new;
end
]]></definition>
</function>

<function name="createtriggeruuid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="1"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying" length="0"/>
	</parameter>
	<definition><![CDATA[
declare
    tableName alias for $1;
    query varchar;
begin

    --select f_safe_drop_trigger('trgsetuid', tableName);

    query = 'create trigger trgSetUUID
             before insert or update
             on ' || tableName || '
             for each row 
             execute procedure uuidCheck();';

    execute query;

    return 1;
end
]]></definition>
</function>

<table name="version_table" layer="0" collapse-mode="2" max-obj-count="2" z-value="0">
	<schema name="public"/>
	<role name="yuriy"/>
	<position x="1100" y="60"/>
	<column name="version">
		<type name="character varying" length="0"/>
	</column>
	<column name="short_version">
		<type name="character varying" length="0"/>
	</column>
</table>

<constraint name="fk_id_parent" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="public.tbl_communications" table="public.tbl_communications">
	<columns names="id_parent" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="tbl_communications_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="public.tbl_communication_types" table="public.tbl_communications">
	<columns names="id_type" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<relationship name="rel_tbl_communications_tbl_communications" type="relfk" layer="0"
	 custom-color="#825b3c"
	 src-table="public.tbl_communications"
	 dst-table="public.tbl_communications" reference-fk="fk_id_parent"
	 src-required="false" dst-required="false">
	<line>
		<position x="743.45" y="128.554"/>
	<position x="743.45" y="49"/>
	<position x="634.966" y="49"/>
	</line>
</relationship>

<relationship name="rel_tbl_communications_tbl_communication_types" type="relfk" layer="0"
	 custom-color="#1bc65c"
	 src-table="public.tbl_communications"
	 dst-table="public.tbl_communication_types" reference-fk="tbl_communications_fk"
	 src-required="false" dst-required="true"/>

<permission>
	<object name="public" type="schema"/>
	<roles names="postgres"/>
	<privileges create="true" usage="true"/>
</permission>
<permission>
	<object name="public" type="schema"/>
	<privileges create="true" usage="true"/>
</permission>
</dbmodel>
